#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

//2024.07.14力扣网刷题
// 计数二进制子串――双指针、字符串――简单
//给定一个字符串 s，统计并返回具有相同数量 0 和 1 的非空（连续）子字符串的数量，
//并且这些子字符串中的所有 0 和所有 1 都是成组连续的。
//重复出现（不同位置）的子串也要统计它们出现的次数。
//示例 1：
//输入：s = "00110011"
//输出：6
//解释：6 个子串满足具有相同数量的连续 1 和 0 ："0011"、"01"、"1100"、"10"、"0011" 和 "01" 。
//注意，一些重复出现的子串（不同位置）要统计它们出现的次数。
//另外，"00110011" 不是有效的子串，因为所有的 0（还有 1 ）没有组合在一起。
//示例 2：
//输入：s = "10101"
//输出：4
//解释：有 4 个子串："10"、"01"、"10"、"01" ，具有相同数量的连续 1 和 0 。
//提示：
//1 <= s.length <= 10^5
//s[i] 为 '0' 或 '1'

int countBinarySubstrings(char* s) {
	int ans = 0;
	int zero = 0;
	int one = 0;
	int i = 0;
	int flag = 0;
	while (s[i]) {
		//记录'0'的个数
		while (s[i] == '0') {
			zero++;
			i++;
		}
		if (zero)
			flag++;
		//当统计完'0'时，flag变为2，说明最后统计的是'0'
		if (flag == 2) {
			ans += zero > one ? one : zero;
			one = 0;//'1'的数量归零
			flag--;
		}
		//记录'1'的个数
		while (s[i] == '1') {
			one++;
			i++;
		}
		if (one)
			flag++;
		//当统计完'1'时，flag变为2，说明最后统计的是'1'
		if (flag == 2) {
			ans += zero > one ? one : zero;
			zero = 0;//'0'的数量归零
			flag--;
		}
	}
	return ans;
}