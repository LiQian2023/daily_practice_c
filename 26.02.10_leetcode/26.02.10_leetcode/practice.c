#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>
//2026.02.10力扣网刷题
//3803. 统计残差前缀——中级工程师、哈希表、字符串、第4884场周赛——简单
//给你一个仅由小写英文字母组成的字符串 s。
//如果字符串 s 的某个 前缀 中 不同字符的数量 等于 len(prefix) % 3，则该前缀被称为残差前缀（residue）。
//返回字符串 s 中 残差前缀 的数量。
//字符串的 前缀 是一个 非空子字符串，从字符串的开头起始并延伸到任意位置。
//示例 1：
//输入 : s = "abc"
//输出 : 2
//解释 : ​​​​​​​
//前缀 "a" 有 1 个不同字符，且长度模 3 为 1，因此它是一个残差前缀。
//前缀 "ab" 有 2 个不同字符，且长度模 3 为 2，因此它是一个残差前缀。
//前缀 "abc" 不满足条件，因此不是残差前缀。
//因此，答案是 2。
//示例 2：
//输入 : s = "dd"
//输出 : 1
//解释 : ​​​​​​​
//前缀 "d" 有 1 个不同字符，且长度模 3 为 1，因此它是一个残差前缀。
//前缀 "dd" 有 1 个不同字符，但长度模 3 为 2，因此它不是残差前缀。
//因此，答案是 1。
//示例 3：
//输入 : s = "bob"
//输出 : 2
//解释 :
//前缀 "b" 有 1 个不同字符，且长度模 3 为 1，因此它是一个残差前缀。
//前缀 "bo" 有 2 个不同字符，且长度模 3 为 2，因此它是一个残差前缀。
//前缀 "bob" 不满足条件。
//因此，答案是 2。
//提示：
//1 <= s.length <= 100
//s 仅包含小写英文字母。

int residuePrefixes(char* s) {
	int ans = 0, prefix = 0, len = strlen(s);
	bool hash[26] = {0};
	for (int i = 0; i < len; i++) {
		int key = s[i] - 'a';
		if (hash[key] == 0) {
			hash[key] = true;
			prefix += 1;
		}
		if (prefix == (i + 1) % 3) {
			ans += 1;
		}
	}
	return ans;
}